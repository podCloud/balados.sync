# Authentication with Balados Sync API

```elixir
Mix.install([
  {:req, "~> 0.4"},
  {:jason, "~> 1.4"},
  {:joken, "~> 2.6"}
])
```

## Introduction

The Balados Sync API uses JWT (JSON Web Tokens) for authentication. This Livebook demonstrates how to:

1. Generate JWT tokens for testing
2. Use tokens in API requests
3. Work with the `/app-creator` authorization flow

## Configuration

```elixir
# API Configuration
base_url = "http://localhost:4000"
api_base = "#{base_url}/api/v1"
```

## Understanding JWT Structure

Balados Sync expects JWTs with the following claims:

```elixir
# JWT Claims Structure
claims = %{
  "sub" => "user_123",           # User ID (required)
  "jti" => "unique_token_id",    # Unique token ID (required)
  "device_id" => "device_456",   # Device identifier (required)
  "device_name" => "My Device",  # Human-readable device name (required)
  "iat" => :os.system_time(:second),  # Issued at timestamp
  "exp" => :os.system_time(:second) + 86400 * 30  # Expires in 30 days
}

IO.inspect(claims, label: "JWT Claims")
```

## Generating a Test JWT Token

For development and testing, you can generate JWT tokens. In production, tokens should be generated by your authentication service.

```elixir
defmodule TestJWT do
  use Joken.Config

  @impl true
  def token_config do
    default_claims(skip: [:aud, :iss])
  end
end

# Generate a test token (using HS256 for simplicity)
# Note: Production uses RS256 with public/private keys
defmodule TokenGenerator do
  def generate(user_id, device_id, device_name) do
    secret = "your-secret-key-here-change-in-production"

    signer = Joken.Signer.create("HS256", secret)

    claims = %{
      "sub" => user_id,
      "jti" => "token_#{:erlang.unique_integer([:positive])}",
      "device_id" => device_id,
      "device_name" => device_name,
      "iat" => :os.system_time(:second),
      "exp" => :os.system_time(:second) + 86400 * 30
    }

    case Joken.encode_and_sign(claims, signer) do
      {:ok, token, _claims} -> token
      {:error, reason} -> raise "Failed to generate token: #{inspect(reason)}"
    end
  end
end

# Generate a test token
test_token = TokenGenerator.generate("user_alice", "device_laptop_001", "Alice's Laptop")
IO.puts("Generated JWT Token:")
IO.puts(test_token)
```

## Using the App Creator Flow (Recommended)

The `/app-creator` endpoint provides an OAuth-style authorization flow for third-party applications.

### Step 1: Create an Authorization Request

```elixir
# Visit the app creator page in your browser
app_creator_url = "#{base_url}/app-creator"
IO.puts("Visit: #{app_creator_url}")
IO.puts("\nFill in the form to generate an authorization token.")
```

### Step 2: Get Authorization Token from Form

After filling the form at `/app-creator`, you'll receive an authorization token. Use it here:

```elixir
# Paste the token you received from the app-creator form
authorization_token = "paste_your_token_here"

IO.puts("Authorization token: #{authorization_token}")
```

### Step 3: User Authorizes the App

```elixir
# The user visits this URL to authorize your app
authorize_url = "#{base_url}/authorize?token=#{authorization_token}"
IO.puts("User authorization URL:")
IO.puts(authorize_url)
IO.puts("\nUser visits this URL to grant permission to the app.")
```

### Step 4: Use the JWT Token

After authorization, the token from step 2 becomes a valid JWT for API calls:

```elixir
# The authorization_token can now be used as a JWT bearer token
jwt_token = authorization_token

# Test the token with a simple API call
response = Req.get!("#{api_base}/subscriptions",
  headers: [{"authorization", "Bearer #{jwt_token}"}]
)

IO.inspect(response.status, label: "Status")
IO.inspect(response.body, label: "Subscriptions")
```

## Making Authenticated API Requests

Once you have a JWT token (either from app-creator or generated), use it in the Authorization header:

```elixir
# Store your token here
token = test_token  # or use authorization_token from app-creator

# Create a configured Req client
client = Req.new(
  base_url: api_base,
  headers: [{"authorization", "Bearer #{token}"}]
)

# Make authenticated requests
subscriptions_response = Req.get!(client, "/subscriptions")
IO.inspect(subscriptions_response.body, label: "Your Subscriptions")
```

## Testing Authentication

### Test Valid Token

```elixir
# Try to fetch subscriptions with valid token
response = Req.get!("#{api_base}/subscriptions",
  headers: [{"authorization", "Bearer #{token}"}]
)

case response.status do
  200 -> IO.puts("✓ Authentication successful!")
  401 -> IO.puts("✗ Authentication failed - invalid token")
  _ -> IO.puts("✗ Unexpected response: #{response.status}")
end

IO.inspect(response.body, label: "Response")
```

### Test Invalid Token

```elixir
# Try with an invalid token
invalid_response = Req.get("#{api_base}/subscriptions",
  headers: [{"authorization", "Bearer invalid_token_here"}]
)

case invalid_response do
  {:ok, %{status: 401}} -> IO.puts("✓ Invalid token correctly rejected")
  {:ok, %{status: status}} -> IO.puts("✗ Unexpected status: #{status}")
  {:error, reason} -> IO.puts("✗ Request failed: #{inspect(reason)}")
end
```

### Test Missing Token

```elixir
# Try without authentication header
no_auth_response = Req.get("#{api_base}/subscriptions")

case no_auth_response do
  {:ok, %{status: 401}} -> IO.puts("✓ Missing token correctly rejected")
  {:ok, %{status: status}} -> IO.puts("✗ Unexpected status: #{status}")
  {:error, reason} -> IO.puts("✗ Request failed: #{inspect(reason)}")
end
```

## Decoding JWT Tokens

To inspect what's inside a JWT token:

```elixir
defmodule JWTDecoder do
  def decode_without_verification(token) do
    [_header, payload, _signature] = String.split(token, ".")

    # Add padding if necessary
    padded = case rem(String.length(payload), 4) do
      0 -> payload
      n -> payload <> String.duplicate("=", 4 - n)
    end

    payload
    |> String.replace("-", "+")
    |> String.replace("_", "/")
    |> Base.decode64!(padding: false)
    |> Jason.decode!()
  end
end

# Decode your token to see its contents
decoded_claims = JWTDecoder.decode_without_verification(token)
IO.inspect(decoded_claims, label: "Decoded JWT Claims")

# Check expiration
exp = decoded_claims["exp"]
now = :os.system_time(:second)
time_until_expiry = exp - now

IO.puts("\nToken expires in #{div(time_until_expiry, 86400)} days")
```

## Best Practices

1. **Never commit tokens to version control** - Use environment variables
2. **Use short-lived tokens** - Implement token refresh mechanisms
3. **Store tokens securely** - Use secure storage on client devices
4. **Implement token refresh** - Don't wait for expiration
5. **Validate on server** - Always verify signature and claims
6. **Use HTTPS in production** - Never send tokens over HTTP

## Next Steps

* [Subscriptions API](subscriptions.livemd) - Subscribe to podcasts
* [Play Status API](play_status.livemd) - Track listening progress
* [App Authorization](app_authorization.livemd) - Complete OAuth flow
* [Getting Started Guide](../guides/getting_started.livemd) - Full tutorial

## Troubleshooting

### Token is rejected (401)

* Check token format: should be `Bearer <token>`
* Verify token hasn't expired
* Ensure token signature is valid
* Confirm required claims are present

### Token generation fails

* Check JWT library installation
* Verify secret key is set
* Ensure all required claims are included

### App creator flow doesn't work

* Verify the server is running on localhost:4000
* Check that you've visited the authorize URL
* Ensure the token hasn't been used already
