# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Balados Sync is a CQRS/Event Sourcing system for synchronizing podcast listens, subscriptions, and playlists. The project was originally generated by Claude.AI following instructions in `ORIGINAL_NOTE.md`. This is an Elixir umbrella application using Commanded for CQRS/ES and EventStore for event persistence.

## Architecture

This is an umbrella application with four main apps:

### balados_sync_core (Domain/CQRS/ES)
- **Commands**: User intentions (Subscribe, RecordPlay, ChangePrivacy, etc.)
- **Events**: Immutable events (UserSubscribed, PlayRecorded, PrivacyChanged, etc.)
- **Aggregates**: Business logic encapsulated in `User` aggregate
- **Dispatcher**: Command routing using Commanded
- All commands are routed to the `User` aggregate identified by `user_id`
- The aggregate maintains state for subscriptions, play_statuses, playlists, and privacy settings

### balados_sync_projections (Read Models)
- **Schemas**: PostgreSQL tables for read models (subscriptions, play_statuses, playlists, podcast_popularity, episode_popularity)
- **Projectors**: Event handlers that update read models
- Three schemas: `users` (user data), `site` (public data), `events` (EventStore-managed)
- Uses Ecto for database interactions

### balados_sync_web (REST API)
- **Controllers**: HTTP endpoints for sync, subscriptions, play status, episodes, privacy, RSS proxy, and public data
- Subdomain routing: `play.balados.sync` for play gateway (tracks listens and redirects to enclosures)
- Phoenix-based REST API with JWT authentication (RS256)

### balados_sync_jobs (Background Workers)
- **SnapshotWorker**: Runs every 5 minutes to:
  - Create checkpoints for users with events >45 days old
  - Recalculate popularity scores (subscribe=10, play=5, save/like=3, share=2 points)
  - Clean up events >31 days old after checkpointing

## Development Commands

### Initial Setup
```bash
# Install dependencies
mix deps.get

# Create databases
mix ecto.create
mix event_store.create -a balados_sync_core

# Initialize event store
mix event_store.init -a balados_sync_core

# Run migrations
cd apps/balados_sync_projections
mix ecto.migrate
cd ../..
```

### Running the Application
```bash
# Start the server (runs on http://localhost:4000)
mix phx.server

# Interactive console with all apps loaded
iex -S mix
```

### Testing
```bash
# Run all tests
mix test

# Test specific app
cd apps/balados_sync_core && mix test

# Test with coverage
mix test --cover

# Run single test file
mix test apps/balados_sync_core/test/some_test.exs

# Run single test by line number
mix test apps/balados_sync_core/test/some_test.exs:42
```

### Database Operations
```bash
# Reset projections database (NOT event store!)
cd apps/balados_sync_projections
mix ecto.reset

# Create new migration
cd apps/balados_sync_projections
mix ecto.gen.migration migration_name

# Run migrations
cd apps/balados_sync_projections
mix ecto.migrate

# Rollback last migration
cd apps/balados_sync_projections
mix ecto.rollback
```

### Formatting and Linting
```bash
# Format code
mix format

# Format specific files
mix format apps/balados_sync_core/lib/some_file.ex
```

### Production Build
```bash
# Build release
MIX_ENV=prod mix release

# Run release
_build/prod/rel/balados_sync/bin/balados_sync start
```

## Key Architectural Patterns

### CQRS/Event Sourcing Flow
1. **Command** arrives via HTTP (e.g., POST /api/v1/subscriptions)
2. **Controller** extracts JWT, creates Command struct
3. **Dispatcher** routes Command to User aggregate by `user_id`
4. **Aggregate** validates and returns Event(s)
5. **EventStore** persists immutable Event
6. **Projectors** listen to Events and update read models
7. **Controller** queries projections and returns response

### Adding New Commands/Events
When adding new functionality, follow this pattern:

1. Create Command struct in `apps/balados_sync_core/lib/balados_sync_core/commands/`
2. Create Event struct in `apps/balados_sync_core/lib/balados_sync_core/events/`
3. Add `execute/2` handler in `User` aggregate that validates and returns Event
4. Add `apply/2` handler in `User` aggregate to update aggregate state
5. Register Command in `Dispatcher.Router`
6. Create/update Projector to handle Event and update read models
7. Add controller action if HTTP endpoint needed

### Aggregate State Management
The `User` aggregate maintains state through event sourcing:
- State is rebuilt by replaying all events for a user
- `execute/2` functions decide what events to emit (based on commands)
- `apply/2` functions update aggregate state (based on events)
- State includes: subscriptions, play_statuses, playlists, privacy settings

### Data Encoding
- RSS feed URLs are base64-encoded as `rss_source_feed`
- Episode identifiers are base64-encoded as `rss_source_item` (format: `"#{guid},#{enclosure_url}"`)
- JWT tokens use RS256 signing with public/private key pairs

### Privacy System
Three levels: `public` (visible with user_id), `anonymous` (visible without user_id), `private` (hidden)
- Configurable globally per user
- Can override per podcast feed
- Can override per individual episode
- Privacy changes update the `site.public_events` projection

### Checkpoint and Cleanup System
The SnapshotWorker performs maintenance every 5 minutes:
1. Finds events older than 45 days
2. Creates `UserCheckpoint` events with current aggregate state
3. Checkpoints are upserted into projections (considered source of truth)
4. Recalculates popularity scores from `site.public_events`
5. Deletes events older than 31 days (after checkpoint)

### Sync Strategy
The `/api/v1/sync` endpoint compares client state with server state:
- **Subscriptions**: Takes most recent timestamp (subscribed_at vs unsubscribed_at)
- **Play statuses**: Takes most recent `updated_at`
- **Playlists**: TODO (needs added/removed dates)
- Emits individual events for each diff
- Creates checkpoint after sync completes

## Testing Patterns

### Dispatching Commands in Tests
```elixir
alias BaladosSyncCore.Dispatcher
alias BaladosSyncCore.Commands.Subscribe

Dispatcher.dispatch(%Subscribe{
  user_id: "user_123",
  device_id: "device_456",
  device_name: "iPhone",
  rss_source_feed: "base64_encoded_feed",
  rss_source_id: "podcast_id"
})
```

### Querying Projections in Tests
```elixir
alias BaladosSyncProjections.Repo
alias BaladosSyncProjections.Schemas.Subscription

Repo.all(Subscription)
Repo.get_by(Subscription, user_id: "user_123")
```

## Configuration Notes

### Environment Variables
- `DATABASE_URL`: PostgreSQL connection for projections
- `EVENT_STORE_URL`: PostgreSQL connection for EventStore
- `SECRET_KEY_BASE`: Phoenix secret key
- `PHX_HOST`: Production hostname
- `PORT`: HTTP port (default 4000)

### JWT Authentication
JWTs must contain:
```json
{
  "sub": "user_id",
  "jti": "unique_token_id",
  "device_id": "device_123",
  "device_name": "Device Name",
  "iat": 1234567890,
  "exp": 1234567890
}
```

### Subdomain Configuration
For local testing with `play.balados.sync` subdomain:
1. Add to `/etc/hosts`: `127.0.0.1 balados.sync play.balados.sync`
2. Configure in `config/dev.exs`:
```elixir
config :balados_sync_web, BaladosSyncWeb.Endpoint,
  url: [host: "balados.sync", port: 4000],
  http: [ip: {127, 0, 0, 1}, port: 4000]

config :balados_sync_web,
  play_domain: "play.balados.sync"
```

## Common Gotchas

- **Event Store vs Projections DB**: Never manually modify the EventStore schema. Only interact through Commanded APIs.
- **Replaying Events**: If projections get out of sync, reset the projection database with `mix ecto.reset` and projectors will automatically replay all events.
- **Immutability**: Events are immutable. To "delete" data, emit new events (like PrivacyChanged or EventsRemoved).
- **Aggregate Consistency**: Always dispatch commands through the Dispatcher to ensure proper event sourcing.
- **Testing Event Store**: The EventStore requires a separate database for tests. Ensure proper test configuration.
- **Snapshot Command**: The `CreateCheckpoint` command should only be called by the SnapshotWorker, not manually.

## Useful IEx Commands

```elixir
# Check aggregate state
alias BaladosSyncCore.Dispatcher
Dispatcher.aggregate_state(BaladosSyncCore.Aggregates.User, "user_123")

# Query event stream
alias BaladosSyncCore.EventStore
EventStore.read_stream_forward("user-user_123")

# Check projector state
BaladosSyncProjections.Projectors.SubscriptionProjector.state()
```
